# Guia de Implementa√ß√£o do Redis Cache - Projeto Quarkus

Este guia fornece instru√ß√µes completas para implementar cache Redis em projetos Quarkus.

## üìã Pr√©-requisitos

### 1. Depend√™ncias Maven

Adicione as seguintes depend√™ncias no seu `pom.xml`:

```xml
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-redis-client</artifactId>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
</dependency>
```

### 2. Configura√ß√£o do Redis

Configure o Redis no arquivo `application.properties`:

```properties
# Redis Configuration
quarkus.redis.redis-[SEU-PROJETO].hosts=${REDIS_HOST}
quarkus.redis.redis-[SEU-PROJETO].password=${REDIS_PASSWORD}

# Cache TTL Configuration
[seu-prefixo].cache.[nome-do-cache].ttl-seconds=86400
```

**Exemplo:**
```properties
# Redis Configuration
quarkus.redis.redis-meu-projeto.hosts=${REDIS_HOST}
quarkus.redis.redis-meu-projeto.password=${REDIS_PASSWORD}

# Cache TTL Configuration
meu-projeto.cache.usuarios.ttl-seconds=3600
meu-projeto.cache.produtos.ttl-seconds=7200
```

## ÔøΩ IMPORTANTE: Escopo da Solicita√ß√£o

### ‚ö†Ô∏è "Configure o Redis cache nessa aplica√ß√£o"

Quando voc√™ receber uma solicita√ß√£o para **"configurar o Redis cache"** em uma aplica√ß√£o, isso significa:

#### ‚úÖ O QUE FAZER:
1. **Adicionar as depend√™ncias Maven** (Passo 1)
2. **Configurar o Redis no application.properties** (Passo 2) 
3. **Criar APENAS a classe RemoteCache base** (Passo 3)
4. **N√ÉO implementar cache em features espec√≠ficas**

#### ‚ùå O QUE N√ÉO FAZER:
- ‚ùå N√ÉO criar classes de cache espec√≠ficas (UsuarioCache, ProdutoCache, etc.)
- ‚ùå N√ÉO modificar Services existentes
- ‚ùå N√ÉO modificar Resources/Controllers existentes
- ‚ùå N√ÉO implementar cache em todas as features da aplica√ß√£o

### üìã Configura√ß√£o B√°sica (Quando solicitado "configurar Redis")

Se a solicita√ß√£o for apenas para **configurar** o Redis, execute SOMENTE:

1. **Depend√™ncias Maven** (se√ß√£o 1)
2. **Configura√ß√£o application.properties** (se√ß√£o 2)  
3. **Classe RemoteCache** (Passo 1 da implementa√ß√£o)

### üîß Implementa√ß√£o Completa (Quando solicitado "implementar cache")

Se a solicita√ß√£o for para **implementar cache** em features espec√≠ficas, a√≠ sim execute todos os passos incluindo:
- Classes de cache espec√≠ficas
- Modifica√ß√µes em Services
- Modifica√ß√µes em Resources
- Testes unit√°rios

> **üí° DICA:** Sempre confirme o escopo antes de implementar. A configura√ß√£o b√°sica √© suficiente para deixar o Redis dispon√≠vel na aplica√ß√£o.

## ÔøΩüõ†Ô∏è Implementa√ß√£o Passo a Passo

### Passo 1: Criar a Classe RemoteCache Base

Crie a classe gen√©rica `RemoteCache` que ser√° reutilizada por todos os caches:

```java
package br.gov.caixa.[seu-projeto].repository.cache;

import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import com.fasterxml.jackson.databind.ObjectMapper;

import br.gov.caixa.[seu-projeto].logging.Logger;
import io.quarkus.redis.datasource.RedisDataSource;
import io.quarkus.redis.datasource.value.ValueCommands;
import jakarta.annotation.Nullable;
import jakarta.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class RemoteCache {

    RedisDataSource datasource;

    private final ValueCommands<String, String> commands;
    private final String dataSourceKey;
    private final ObjectMapper objectMapper = new ObjectMapper();

    public RemoteCache() {
        this.datasource = null;
        this.commands = null;
        this.dataSourceKey = null;
    }

    public RemoteCache(String dataSourceKey, RedisDataSource datasource) {
        this.dataSourceKey = dataSourceKey;
        this.datasource = datasource;
        commands = datasource.value(String.class);
    }

    public void set(String key, String value) {
        commands.setnx(formatKey(key), value);
    }

    public void setex(String key, String value, long duration) {
        commands.setex(formatKey(key), duration, value);
    }

    public String get(String key) {
        return commands.get(formatKey(key));
    }

    public void del(String key) {
        commands.getdel(formatKey(key));
    }

    public Set<String> keys() {
        return datasource.key()
                .keys(formatKey("*"))
                .stream()
                .collect(Collectors.toSet());
    }

    public Map<String, String> list() {
        return commands.mget(formatKey(""));
    }

    private String formatKey(String key) {
        return dataSourceKey + ":" + key;
    }

    @Nullable
    public <T> T getValue(String key, Class<T> clazz) {
        try {
            String value = get(key);
            if (value != null) {
                return objectMapper.readValue(value, clazz);
            }
            return null;
        } catch (Exception e) {
            Logger.system().errorf("Failed to deserialize cache value for key: %s", e, key);
            return null;
        }
    }

    public void setValue(String key, Object value, long ttlSeconds) {
        try {
            String jsonValue = objectMapper.writeValueAsString(value);
            setex(key, jsonValue, ttlSeconds);
        } catch (Exception e) {
            Logger.system().errorf("Failed to save cache value for key: %s", e, key);
        }
    }
}
```

### Passo 2: Criar Classes de Cache Espec√≠ficas

Para cada entidade que voc√™ deseja cachear, crie uma classe espec√≠fica:

#### Exemplo: Cache de Usu√°rios

```java
package br.gov.caixa.[seu-projeto].repository.cache;

import org.eclipse.microprofile.config.inject.ConfigProperty;

import br.gov.caixa.[seu-projeto].model.Usuario;
import io.quarkus.redis.client.RedisClientName;
import io.quarkus.redis.datasource.RedisDataSource;
import jakarta.annotation.Nullable;
import jakarta.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class UsuarioCache {

    @ConfigProperty(name = "[seu-prefixo].cache.usuarios.ttl-seconds")
    public long ttlSeconds;

    private static final String USUARIOS_KEY = "usuarios";

    protected final RemoteCache redisCache;

    public UsuarioCache(@RedisClientName("redis-[seu-projeto]") RedisDataSource redisDataSource) {
        this.redisCache = new RemoteCache("[SEU_PROJETO_UPPERCASE]", redisDataSource);
    }

    // Cache simples (chave √∫nica)
    @Nullable
    public Usuario get(String userId) {
        var key = String.format("%s-%s", USUARIOS_KEY, userId);
        return this.redisCache.getValue(key, Usuario.class);
    }

    public void set(Usuario usuario, String userId) {
        var key = String.format("%s-%s", USUARIOS_KEY, userId);
        this.redisCache.setValue(key, usuario, ttlSeconds);
    }

    // Cache com m√∫ltiplos par√¢metros
    @Nullable
    public Usuario getByEmailAndDepartamento(String email, String departamento) {
        var key = String.format("%s-email-%s-dept-%s", USUARIOS_KEY, email, departamento);
        return this.redisCache.getValue(key, Usuario.class);
    }

    public void setByEmailAndDepartamento(Usuario usuario, String email, String departamento) {
        var key = String.format("%s-email-%s-dept-%s", USUARIOS_KEY, email, departamento);
        this.redisCache.setValue(key, usuario, ttlSeconds);
    }

    // Invalidar cache espec√≠fico
    public void invalidate(String userId) {
        var key = String.format("%s-%s", USUARIOS_KEY, userId);
        this.redisCache.del(key);
    }
}
```

#### Exemplo: Cache de Produtos (com cache geral e espec√≠fico)

```java
package br.gov.caixa.[seu-projeto].repository.cache;

import org.eclipse.microprofile.config.inject.ConfigProperty;

import br.gov.caixa.[seu-projeto].model.Produto;
import io.quarkus.redis.client.RedisClientName;
import io.quarkus.redis.datasource.RedisDataSource;
import jakarta.annotation.Nullable;
import jakarta.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class ProdutoCache {

    @ConfigProperty(name = "[seu-prefixo].cache.produtos.ttl-seconds")
    public long ttlSeconds;

    private static final String PRODUTOS_KEY = "produtos";
    private static final String PRODUTOS_LIST_KEY = "produtos-list";

    protected final RemoteCache redisCache;

    public ProdutoCache(@RedisClientName("redis-[seu-projeto]") RedisDataSource redisDataSource) {
        this.redisCache = new RemoteCache("[SEU_PROJETO_UPPERCASE]", redisDataSource);
    }

    // Cache para lista completa
    @Nullable
    public List<Produto> getAll() {
        return this.redisCache.getValue(PRODUTOS_LIST_KEY, new TypeReference<List<Produto>>() {}.getClass());
    }

    public void setAll(List<Produto> produtos) {
        this.redisCache.setValue(PRODUTOS_LIST_KEY, produtos, ttlSeconds);
    }

    // Cache para produto espec√≠fico
    @Nullable
    public Produto get(String produtoId) {
        var key = String.format("%s-%s", PRODUTOS_KEY, produtoId);
        return this.redisCache.getValue(key, Produto.class);
    }

    public void set(Produto produto, String produtoId) {
        var key = String.format("%s-%s", PRODUTOS_KEY, produtoId);
        this.redisCache.setValue(key, produto, ttlSeconds);
    }

    // Cache com filtros
    @Nullable
    public List<Produto> getByCategoria(String categoria) {
        var key = String.format("%s-categoria-%s", PRODUTOS_KEY, categoria);
        return this.redisCache.getValue(key, new TypeReference<List<Produto>>() {}.getClass());
    }

    public void setByCategoria(List<Produto> produtos, String categoria) {
        var key = String.format("%s-categoria-%s", PRODUTOS_KEY, categoria);
        this.redisCache.setValue(key, produtos, ttlSeconds);
    }
}
```

### Passo 3: Integrar o Cache no Service

Utilize o cache no seu service seguindo o padr√£o:

```java
package br.gov.caixa.[seu-projeto].service;

import br.gov.caixa.[seu-projeto].repository.cache.UsuarioCache;
import br.gov.caixa.[seu-projeto].model.Usuario;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

@ApplicationScoped
public class UsuarioService {

    @Inject
    UsuarioCache usuarioCache;

    @Inject
    UsuarioRepository usuarioRepository;

    public Usuario getUsuario(String userId, Boolean noCache) {
        // Se noCache n√£o for true, tenta buscar no cache
        if (!Boolean.TRUE.equals(noCache)) {
            var cachedUsuario = usuarioCache.get(userId);
            if (cachedUsuario != null) {
                return cachedUsuario;
            }
        }

        // Busca no reposit√≥rio/API
        var usuario = usuarioRepository.findById(userId);
        
        // Salva no cache se encontrou o usu√°rio
        if (usuario != null) {
            usuarioCache.set(usuario, userId);
        }

        return usuario;
    }

    public Usuario atualizarUsuario(String userId, Usuario usuarioAtualizado) {
        // Atualiza no reposit√≥rio
        var usuario = usuarioRepository.update(userId, usuarioAtualizado);
        
        // Invalida o cache ou atualiza com novo valor
        usuarioCache.set(usuario, userId);
        
        return usuario;
    }

    public void deletarUsuario(String userId) {
        // Remove do reposit√≥rio
        usuarioRepository.delete(userId);
        
        // Invalida o cache
        usuarioCache.invalidate(userId);
    }
}
```

### Passo 4: Integrar no Resource/Controller

```java
package br.gov.caixa.[seu-projeto].resource;

import br.gov.caixa.[seu-projeto].service.UsuarioService;
import br.gov.caixa.[seu-projeto].model.Usuario;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import org.jboss.resteasy.reactive.RestResponse;

@Path("/v1/usuarios")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class UsuarioResource {

    @Inject
    UsuarioService usuarioService;

    @GET
    @Path("/{userId}")
    public RestResponse<Usuario> getUsuario(
            @PathParam("userId") String userId,
            @HeaderParam("no-cache") @DefaultValue("false") Boolean noCache) {
        
        var usuario = usuarioService.getUsuario(userId, noCache);
        return RestResponse.ok(usuario);
    }

    @PUT
    @Path("/{userId}")
    public RestResponse<Usuario> atualizarUsuario(
            @PathParam("userId") String userId, 
            Usuario usuario) {
        
        var usuarioAtualizado = usuarioService.atualizarUsuario(userId, usuario);
        return RestResponse.ok(usuarioAtualizado);
    }

    @DELETE
    @Path("/{userId}")
    public RestResponse<Void> deletarUsuario(@PathParam("userId") String userId) {
        usuarioService.deletarUsuario(userId);
        return RestResponse.noContent();
    }
}
```

## üß™ Testes Unit√°rios

### Exemplo de Teste para Cache

```java
package unit.br.gov.caixa.[seu-projeto].repository.cache;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import br.gov.caixa.[seu-projeto].repository.cache.UsuarioCache;
import br.gov.caixa.[seu-projeto].repository.cache.RemoteCache;
import br.gov.caixa.[seu-projeto].model.Usuario;
import io.quarkus.redis.datasource.RedisDataSource;

class UsuarioCacheTest {

    private static final String TEST_USER_ID = "12345";
    private static final long TEST_TTL_SECONDS = 3600L;

    private UsuarioCache usuarioCache;
    private RemoteCache mockRemoteCache;
    private RedisDataSource mockRedisDataSource;

    @BeforeEach
    void setUp() {
        mockRedisDataSource = mock(RedisDataSource.class);
        mockRemoteCache = mock(RemoteCache.class);

        usuarioCache = new UsuarioCache(mockRedisDataSource);
        usuarioCache.ttlSeconds = TEST_TTL_SECONDS;

        // Injeta o mock usando reflection
        try {
            var field = UsuarioCache.class.getDeclaredField("redisCache");
            field.setAccessible(true);
            field.set(usuarioCache, mockRemoteCache);
        } catch (Exception e) {
            throw new RuntimeException("Failed to inject mock RemoteCache", e);
        }
    }

    @Test
    void get_when_cacheHasData_should_returnCachedUser() {
        // Arrange
        Usuario expectedUser = createMockUser();
        String expectedKey = "usuarios-" + TEST_USER_ID;
        when(mockRemoteCache.getValue(expectedKey, Usuario.class)).thenReturn(expectedUser);

        // Act
        Usuario actualUser = usuarioCache.get(TEST_USER_ID);

        // Assert
        assertNotNull(actualUser);
        assertEquals(expectedUser, actualUser);
        verify(mockRemoteCache).getValue(expectedKey, Usuario.class);
    }

    @Test
    void set_when_userProvided_should_delegateToRemoteCacheWithCorrectTtl() {
        // Arrange
        Usuario testUser = createMockUser();
        String expectedKey = "usuarios-" + TEST_USER_ID;

        // Act
        usuarioCache.set(testUser, TEST_USER_ID);

        // Assert
        verify(mockRemoteCache).setValue(expectedKey, testUser, TEST_TTL_SECONDS);
    }

    private Usuario createMockUser() {
        Usuario user = mock(Usuario.class);
        when(user.getId()).thenReturn(TEST_USER_ID);
        when(user.getNome()).thenReturn("Jo√£o da Silva");
        return user;
    }
}
```

## üìù Padr√µes e Conven√ß√µes

### 1. Nomenclatura de Chaves

- Use prefixos consistentes: `[entidade]-[identificador]`
- Para chaves compostas: `[entidade]-[param1]-[valor1]-[param2]-[valor2]`
- Exemplos:
  - `usuarios-12345`
  - `produtos-categoria-eletronicos`
  - `parametros-canal-WEB`

### 2. Configura√ß√µes TTL

- Configure TTLs apropriados baseados na frequ√™ncia de mudan√ßa dos dados
- Use vari√°veis de ambiente para facilitar ajustes:
  ```properties
  # Dados que mudam frequentemente
  cache.usuarios-sessao.ttl-seconds=300    # 5 minutos
  
  # Dados est√°veis
  cache.parametros-sistema.ttl-seconds=86400  # 24 horas
  
  # Dados raramente alterados
  cache.configuracoes.ttl-seconds=604800   # 7 dias
  ```

### 3. Estrat√©gias de Cache

#### Cache-Aside (Recomendado)
```java
public Usuario getUsuario(String id) {
    // 1. Verifica cache
    Usuario usuario = cache.get(id);
    if (usuario != null) {
        return usuario;
    }
    
    // 2. Busca no banco
    usuario = repository.findById(id);
    
    // 3. Salva no cache
    if (usuario != null) {
        cache.set(usuario, id);
    }
    
    return usuario;
}
```

#### Write-Through
```java
public Usuario salvarUsuario(Usuario usuario) {
    // 1. Salva no banco
    Usuario usuarioSalvo = repository.save(usuario);
    
    // 2. Atualiza cache
    cache.set(usuarioSalvo, usuarioSalvo.getId());
    
    return usuarioSalvo;
}
```

#### Write-Behind (Invalida√ß√£o)
```java
public void atualizarUsuario(String id, Usuario usuario) {
    // 1. Atualiza no banco
    repository.update(id, usuario);
    
    // 2. Invalida cache (ser√° recarregado na pr√≥xima busca)
    cache.invalidate(id);
}
```

## ÔøΩ Configura√ß√£o de Logging

### Verifica√ß√£o do Logger Dispon√≠vel

Antes de implementar logs de erro, **SEMPRE** verifique se o Logger customizado da Caixa est√° dispon√≠vel:

```java
import br.gov.caixa.silce.logging.Logger;
```

#### Regras de Uso do Logger:

1. **Se o import `br.gov.caixa.silce.logging.Logger` estiver dispon√≠vel:**
   - Use: `Logger.system().errorf("mensagem", exception, parametros)`
   
2. **Se o import N√ÉO estiver dispon√≠vel:**
   - Use o logger padr√£o do Quarkus: `Log.errorf("mensagem", exception, parametros)`
   - Adicione o import: `import io.quarkus.logging.Log;`

#### Exemplo de Implementa√ß√£o:

```java
// Na classe RemoteCache
@Nullable
public <T> T getValue(String key, Class<T> clazz) {
    try {
        String value = get(key);
        if (value != null) {
            return objectMapper.readValue(value, clazz);
        }
        return null;
    } catch (Exception e) {
        // VERIFICAR SE br.gov.caixa.silce.logging.Logger EST√Å DISPON√çVEL
        
        // Se dispon√≠vel, use:
        Logger.system().errorf("Failed to deserialize cache value for key: %s", e, key);
        
        // Se N√ÉO dispon√≠vel, use:
        // Log.errorf("Failed to deserialize cache value for key: %s", e, key);
        
        return null;
    }
}

public void setValue(String key, Object value, long ttlSeconds) {
    try {
        String jsonValue = objectMapper.writeValueAsString(value);
        setex(key, jsonValue, ttlSeconds);
    } catch (Exception e) {
        // VERIFICAR SE br.gov.caixa.silce.logging.Logger EST√Å DISPON√çVEL
        
        // Se dispon√≠vel, use:
        Logger.system().errorf("Failed to save cache value for key: %s", e, key);
        
        // Se N√ÉO dispon√≠vel, use:
        // Log.errorf("Failed to save cache value for key: %s", e, key);
    }
}
```

#### Template de Verifica√ß√£o:

```java
// No in√≠cio do arquivo, tente importar o Logger customizado
try {
    // Se este import funcionar, use Logger.system().errorf
    import br.gov.caixa.silce.logging.Logger;
} catch (ImportException e) {
    // Se falhar, use o logger padr√£o
    import io.quarkus.logging.Log;
}
```

> **‚ö†Ô∏è IMPORTANTE:** Esta verifica√ß√£o deve ser feita em **TODAS** as classes que implementam logging de erro no Redis cache.

## ÔøΩüîß Configura√ß√µes Avan√ßadas

### Configura√ß√£o de Cluster Redis

```properties
# Configura√ß√£o para cluster Redis
quarkus.redis.redis-meu-projeto.hosts=redis-node1:6379,redis-node2:6379,redis-node3:6379
quarkus.redis.redis-meu-projeto.password=${REDIS_PASSWORD}
quarkus.redis.redis-meu-projeto.client-type=CLUSTER
```

### Configura√ß√£o com SSL

```properties
# Configura√ß√£o com SSL
quarkus.redis.redis-meu-projeto.ssl=true
quarkus.redis.redis-meu-projeto.trust-all=false
quarkus.redis.redis-meu-projeto.trust-store-path=/path/to/truststore.jks
quarkus.redis.redis-meu-projeto.trust-store-password=${TRUSTSTORE_PASSWORD}
```

### Configura√ß√£o de Pool de Conex√µes

```properties
# Pool de conex√µes
quarkus.redis.redis-meu-projeto.max-pool-size=20
quarkus.redis.redis-meu-projeto.max-pool-waiting=24
```

## üìä Monitoramento e Observabilidade

### M√©tricas Personalizadas

```java
import io.micrometer.core.annotation.Counted;
import io.micrometer.core.annotation.Timed;

@ApplicationScoped
public class UsuarioCache {
    
    @Counted(value = "cache.usuarios.hits", description = "N√∫mero de cache hits")
    @Timed(value = "cache.usuarios.get.time", description = "Tempo de busca no cache")
    public Usuario get(String userId) {
        return this.redisCache.getValue(formatKey(userId), Usuario.class);
    }
    
    @Counted(value = "cache.usuarios.sets", description = "N√∫mero de escritas no cache")
    @Timed(value = "cache.usuarios.set.time", description = "Tempo de escrita no cache")
    public void set(Usuario usuario, String userId) {
        this.redisCache.setValue(formatKey(userId), usuario, ttlSeconds);
    }
}
```

### Health Check do Redis

```java
import org.eclipse.microprofile.health.HealthCheck;
import org.eclipse.microprofile.health.HealthCheckResponse;
import org.eclipse.microprofile.health.Readiness;

@Readiness
@ApplicationScoped
public class RedisHealthCheck implements HealthCheck {
    
    @Inject
    @RedisClientName("redis-meu-projeto")
    RedisDataSource redisDataSource;
    
    @Override
    public HealthCheckResponse call() {
        try {
            redisDataSource.value(String.class).set("health-check", "ok");
            return HealthCheckResponse.up("Redis connection");
        } catch (Exception e) {
            return HealthCheckResponse.down("Redis connection failed: " + e.getMessage());
        }
    }
}
```

## üöÄ Exemplo Completo

Voc√™ pode encontrar um exemplo completo funcional no projeto `silce-parametros-gestao`, que inclui:

- ‚úÖ Configura√ß√£o do Redis
- ‚úÖ Implementa√ß√£o do RemoteCache
- ‚úÖ Caches espec√≠ficos (ParametrosCanalCache, ParametrosSimulacaoCache)
- ‚úÖ Integra√ß√£o com Services
- ‚úÖ Testes unit√°rios completos
- ‚úÖ Uso em Resources REST

## üìö Refer√™ncias

- [Documenta√ß√£o Oficial Quarkus Redis](https://quarkus.io/guides/redis)
- [Redis Commands Reference](https://redis.io/commands)
- [Jackson Documentation](https://github.com/FasterXML/jackson-docs)

## üÜò Troubleshooting

### Problemas Comuns

1. **Erro de Conex√£o**: Verifique se as vari√°veis `REDIS_HOST` e `REDIS_PASSWORD` est√£o configuradas
2. **Serializa√ß√£o**: Certifique-se que os objetos s√£o serializ√°veis (possuem construtor padr√£o)
3. **Performance**: Monitore o tamanho dos objetos no cache e ajuste TTLs conforme necess√°rio
4. **Mem√≥ria**: Configure limits apropriados no Redis para evitar out-of-memory

### Logs de Debug

```properties
# Habilitar logs de debug para Redis
quarkus.log.category."io.quarkus.redis".level=DEBUG
```

---

Este guia fornece uma base s√≥lida para implementar cache Redis em projetos Quarkus. Adapte os exemplos conforme suas necessidades espec√≠ficas e sempre teste em ambiente de desenvolvimento antes de aplicar em produ√ß√£o.